<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>PNG Corruption Maker</title>
	<style>
		body { font-family: sans-serif; margin: 2em; background: #222; color: #eee; }
		.container { max-width: 500px; margin: auto; background: #333; padding: 2em; border-radius: 1em; box-shadow: 0 0 20px #0008; }
		input[type="file"], input[type="number"] { margin: 1em 0; }
		button { padding: 0.5em 1em; font-size: 1em; }
		img { max-width: 100%; margin-top: 1em; border: 1px solid #444; border-radius: 0.5em; }
	</style>
</head>
<body>
	<div class="container">
		<h1>PNG Corruption Maker</h1>
		<p>Upload a PNG, audio, or video file:</p>
		<input type="file" id="fileInput" accept="image/png,audio/*,video/*"><br>
		<label for="corruptionMode">Corruption mode:</label>
		<select id="corruptionMode">
			<option value="bitflip">Bit-flip corruption</option>
			<option value="distance">Distance loss (video only)</option>
		</select><br>
		
		<div id="bitflipControls" style="margin-top:0.5em;">
				<label for="percentInput">Bit-flip percent:</label>
				<input type="number" id="percentInput" min="0" max="100" value="1" style="width:80px; margin-left:0.5em;">
			</div>

		<div id="distanceControls" style="display:none; margin-top:0.5em;">
				<label for="distanceInput">Distance loss (meters, videos only):</label>
				<input type="number" id="distanceInput" min="0" max="1000" value="0" step="0.1" style="width:80px; margin-left:0.5em;">
				<span style="margin-left:8px;color:#999;font-size:0.9em;" id="delayDisplay">0.000s delay</span>
			</div>

			<div id="rotationControls" style="margin-top:0.5em;">
				<label for="rotationMode">Video rotation fix:</label>
				<select id="rotationMode" style="margin-left:0.5em;">
					<option value="none">No rotation</option>
					<option value="ccw">90° Counterclockwise</option>
					<option value="cw">90° Clockwise</option>
				</select>
			</div>

			<div style="margin-top:1em;">
				<button id="corruptBtn">Corrupt</button>
			</div>

		</div>

		<div id="output" style="max-width:800px;margin:1.5em auto;text-align:center"></div>

		<script>
		// Update delay display when distance changes
		window.addEventListener('DOMContentLoaded', function() {
			const corruptionMode = document.getElementById('corruptionMode');
			const bitflipControls = document.getElementById('bitflipControls');
			const distanceControls = document.getElementById('distanceControls');
			const distanceInput = document.getElementById('distanceInput');
			const delayDisplay = document.getElementById('delayDisplay');
			
			// Toggle between modes
			if (corruptionMode) {
				corruptionMode.addEventListener('change', function() {
					if (corruptionMode.value === 'bitflip') {
						bitflipControls.style.display = '';
						distanceControls.style.display = 'none';
					} else if (corruptionMode.value === 'distance') {
						bitflipControls.style.display = 'none';
						distanceControls.style.display = '';
					} else {
						bitflipControls.style.display = 'none';
						distanceControls.style.display = 'none';
					}
				});
			}
			
			if (distanceInput && delayDisplay) {
				distanceInput.addEventListener('input', function() {
					const distance = parseFloat(distanceInput.value) || 0;
					const delay = distance / 343; // speed of sound ~343 m/s
					delayDisplay.textContent = delay.toFixed(3) + 's delay';
				});
			}
		});

		function flipBits(buffer, percent) {
			const totalBits = buffer.byteLength * 8;
			const bitsToFlip = Math.floor(totalBits * (percent / 100));
			const view = new Uint8Array(buffer);
			const flipped = new Set();
			while (flipped.size < bitsToFlip) {
				const bitIndex = Math.floor(Math.random() * totalBits);
				if (flipped.has(bitIndex)) continue;
				flipped.add(bitIndex);
				const byteIndex = Math.floor(bitIndex / 8);
				const bitInByte = bitIndex % 8;
				view[byteIndex] ^= (1 << bitInByte);
			}
			return buffer;
		}

	// Distance Loss: Simple approach using video element timing
	async function applyDistanceLoss(videoBlob, delaySeconds, rotationMode = 'none') {
		if (delaySeconds <= 0 && rotationMode === 'none') return videoBlob;

		return new Promise((resolve, reject) => {
			const videoURL = URL.createObjectURL(videoBlob);
			const video = document.createElement('video');
			const audioContext = new (window.AudioContext || window.webkitAudioContext)();
			
			video.src = videoURL;

			video.onloadedmetadata = async function() {
				try {
					const canvas = document.createElement('canvas');
					
					// Apply rotation correction if needed
					if (rotationMode === 'ccw' || rotationMode === 'cw') {
						canvas.width = video.videoHeight;
						canvas.height = video.videoWidth;
					} else {
						canvas.width = video.videoWidth;
						canvas.height = video.videoHeight;
					}
					const ctx = canvas.getContext('2d');

					// Set up audio with delay
					const source = audioContext.createMediaElementSource(video);
					const delayNode = audioContext.createDelay(Math.max(10, delaySeconds));
					delayNode.delayTime.value = delaySeconds;
					const destination = audioContext.createMediaStreamDestination();
					source.connect(delayNode);
					delayNode.connect(destination);

					// Use video element's frame rate
					const stream = canvas.captureStream();
					const videoTrack = stream.getVideoTracks()[0];
					const audioTrack = destination.stream.getAudioTracks()[0];

					const combinedStream = new MediaStream([videoTrack, audioTrack]);
					const mediaRecorder = new MediaRecorder(combinedStream, {
						mimeType: 'video/webm'
					});

					const chunks = [];
					mediaRecorder.ondataavailable = (e) => chunks.push(e.data);
					mediaRecorder.onstop = () => {
						const processedBlob = new Blob(chunks, { type: 'video/webm' });
						URL.revokeObjectURL(videoURL);
						audioContext.close();
						resolve(processedBlob);
					};

					mediaRecorder.start();
					video.play();

					// Sync drawing with video time
					let lastDrawTime = -1;
					function drawFrame() {
						if (video.ended) {
							setTimeout(() => mediaRecorder.stop(), delaySeconds * 1000 + 200);
							return;
						}
						
						// Only draw if video time has advanced
						if (video.currentTime !== lastDrawTime) {
							ctx.save();
							if (rotationMode === 'ccw') {
								ctx.translate(0, canvas.height);
								ctx.rotate(-Math.PI / 2);
								ctx.drawImage(video, 0, 0, video.videoWidth, video.videoHeight);
							} else if (rotationMode === 'cw') {
								ctx.translate(canvas.width, 0);
								ctx.rotate(Math.PI / 2);
								ctx.drawImage(video, 0, 0, video.videoWidth, video.videoHeight);
							} else {
								ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
							}
							ctx.restore();
							lastDrawTime = video.currentTime;
						}
						
						requestAnimationFrame(drawFrame);
					}
					requestAnimationFrame(drawFrame);

				} catch (err) {
					URL.revokeObjectURL(videoURL);
					if (audioContext) audioContext.close();
					reject(err);
				}
			};

			video.onerror = () => {
				URL.revokeObjectURL(videoURL);
				if (audioContext) audioContext.close();
				reject(new Error('Failed to load video'));
			};
		});
	}		document.getElementById('corruptBtn').onclick = async function() {
			const fileInput = document.getElementById('fileInput');
			const corruptionMode = document.getElementById('corruptionMode').value;
			const percent = parseFloat(document.getElementById('percentInput').value);
			const output = document.getElementById('output');
			output.innerHTML = '';

			let file = fileInput.files[0];
			let corruptedBuffer, blob, url, ext, type;

			if (file) {
				const name = file.name.toLowerCase();
				if (name.match(/\.(png|jpg|jpeg)$/)) {
					if (corruptionMode === 'distance') {
						output.textContent = 'Distance loss only applies to video files.';
						return;
					}
					const reader = new FileReader();
					reader.onload = function(e) {
						const arrayBuffer = e.target.result;
						const percent = parseFloat(document.getElementById('percentInput').value);
						let attempts = 0;
						let lastUrl = null;

							function tryOnce() {
								attempts++;
								// create a fresh corrupted copy for each attempt
								const corruptedBuffer = flipBits(arrayBuffer.slice(0), percent);
								const blob = new Blob([corruptedBuffer], {type: file.type || 'image/png'});
								const url = URL.createObjectURL(blob);

								const testImg = new Image();
								testImg.onload = function() {
									// success: revoke previous failed URL, keep current for download/preview
									if (lastUrl && lastUrl !== url) try { URL.revokeObjectURL(lastUrl); } catch (err) {}
									const outImg = document.createElement('img');
									outImg.src = url;
									outImg.alt = 'Bit-flip corrupted image';
									output.appendChild(outImg);
									const dl = document.createElement('a');
									dl.href = url;
									dl.download = 'bitflip_' + file.name;
									dl.textContent = 'Download bit-flip corrupted image';
									dl.style.display = 'block';
									dl.style.marginTop = '1em';
									output.appendChild(dl);
								};
								testImg.onerror = function() {
									// failed to load as image; revoke this url and retry up to 100 times
									try { URL.revokeObjectURL(url); } catch (err) {}
									if (attempts < 100) {
										// small delay to avoid locking event loop
										setTimeout(tryOnce, 0);
									} else {
										output.textContent = 'Could not produce a valid image after 100 attempts.';
									}
								};

								lastUrl = url;
								// trigger load attempt
								testImg.src = url;
							}

						tryOnce();
					};
					reader.onerror = function() { output.textContent = 'Could not read image.'; };
					reader.readAsArrayBuffer(file);
					return;
			} else if (name.match(/\.(mp3|wav|ogg|flac|aac)$/)) {
				if (corruptionMode === 'distance') {
					output.textContent = 'Distance loss only applies to video files.';
					return;
				}
				const arrayBuffer = await file.arrayBuffer();
				corruptedBuffer = flipBits(arrayBuffer.slice(0), percent);
				blob = new Blob([corruptedBuffer], {type: file.type || 'audio/mpeg'});
				url = URL.createObjectURL(blob);
				type = 'audio';
				ext = name.split('.').pop();
				} else if (name.match(/\.(mp4|webm|ogg|avi|mov|mkv)$/)) {
					const arrayBuffer = await file.arrayBuffer();
					const rotationMode = document.getElementById('rotationMode').value;
					let videoBlob;
					
					if (corruptionMode === 'bitflip') {
						// Apply bit-flip corruption
						corruptedBuffer = flipBits(arrayBuffer.slice(0), percent);
						videoBlob = new Blob([corruptedBuffer], {type: file.type || 'video/mp4'});
						
						// Apply rotation if needed for bit-flip mode
						if (rotationMode !== 'none') {
							try {
								output.innerHTML = '<p>Applying rotation correction...</p>';
								videoBlob = await applyDistanceLoss(videoBlob, 0, rotationMode);
								ext = 'webm';
							} catch (err) {
								console.error('Rotation failed:', err);
								output.innerHTML = '<p style="color:#f66;">Rotation failed. Using video without rotation.</p>';
							}
						}
					} else {
						// Distance mode: just pass through the original video
						videoBlob = new Blob([arrayBuffer], {type: file.type || 'video/mp4'});
					}
					
			// Apply distance loss if in distance mode
			if (corruptionMode === 'distance') {
				const distance = parseFloat(document.getElementById('distanceInput').value) || 0;
				if (distance > 0) {
					const delay = distance / 343; // speed of sound ~343 m/s
					try {
					output.innerHTML = '<p>Processing distance loss (' + delay.toFixed(3) + 's delay)...</p>';
					videoBlob = await applyDistanceLoss(videoBlob, delay, rotationMode);
					ext = 'webm'; // distance loss outputs webm
					} catch (err) {
						console.error('Distance loss processing failed:', err);
						output.innerHTML = '<p style="color:#f66;">Distance loss processing failed. Using original video.</p>';
					}
				} else {
					output.textContent = 'Please enter a distance greater than 0 for distance loss mode.';
					return;
				}
			}
			
			blob = videoBlob;
				url = URL.createObjectURL(blob);
				type = 'video';
				if (!ext) ext = name.split('.').pop();
				} else {
					output.textContent = 'File must be an image, audio, or video file.';
					return;
				}
			} else {
				output.textContent = 'Please select an image, audio, or video file.';
				return;
			}

			if (type === 'image') {
				const img = document.createElement('img');
				img.src = url;
				img.alt = 'Corrupted PNG';
				output.appendChild(img);
				const dl = document.createElement('a');
				dl.href = url;
				dl.download = 'corrupted.' + ext;
				dl.textContent = 'Download corrupted PNG';
				dl.style.display = 'block';
				dl.style.marginTop = '1em';
				output.appendChild(dl);
			} else if (type === 'audio') {
				const audio = document.createElement('audio');
				audio.controls = true;
				audio.src = url;
				output.appendChild(audio);
				const dl = document.createElement('a');
				dl.href = url;
				dl.download = 'corrupted.' + ext;
				dl.textContent = 'Download corrupted audio';
				dl.style.display = 'block';
				dl.style.marginTop = '1em';
				output.appendChild(dl);
			} else if (type === 'video') {
				const video = document.createElement('video');
				video.controls = true;
				video.src = url;
				video.style.maxWidth = '100%';
				output.appendChild(video);
				const dl = document.createElement('a');
				dl.href = url;
				dl.download = 'corrupted.' + ext;
				dl.textContent = 'Download corrupted video';
				dl.style.display = 'block';
				dl.style.marginTop = '1em';
				output.appendChild(dl);
			}
		};
		</script>
</body>
</html>
