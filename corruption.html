<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>PNG Corruption Maker</title>
	<style>
		body { font-family: sans-serif; margin: 2em; background: #222; color: #eee; }
		.container { max-width: 500px; margin: auto; background: #333; padding: 2em; border-radius: 1em; box-shadow: 0 0 20px #0008; }
		input[type="file"], input[type="number"] { margin: 1em 0; }
		button { padding: 0.5em 1em; font-size: 1em; }
		img { max-width: 100%; margin-top: 1em; border: 1px solid #444; border-radius: 0.5em; }
	</style>
</head>
<body>
	<div class="container">
		<h1>PNG Corruption Maker</h1>
		<p>Upload a PNG, audio, or video file:</p>
		<input type="file" id="fileInput" accept="image/png,audio/*,video/*"><br>
		   <label for="imgMode">Image corruption mode:</label>
		   <select id="imgMode">
			   <option value="vhs">VHS simulation</option>
			   <option value="bitflip">Bit-flip corruption</option>
		   </select><br>
		   <div id="vhsControls">
			   <label for="vhsInput">VHS generation (images only):</label>
			   <input type="range" id="vhsInput" min="1" max="30" value="1" style="width:200px;">
			   <input type="number" id="vhsInputNum" min="1" max="100" value="1" style="width:60px;">
			   <span id="vhsLabel">1</span><br>
		   </div>

		<div id="bitflipControls" style="display:none; margin-top:0.5em;">
				<label for="percentInput">Bit-flip percent:</label>
				<input type="number" id="percentInput" min="0" max="100" value="1" style="width:80px; margin-left:0.5em;">
			</div>

			<div style="margin-top:1em;">
				<button id="corruptBtn">Corrupt</button>
			</div>

			<div id="editGreyArea" style="margin-top:1em;">
				<button id="editGreyBtn">Edit Grey</button>
				<div id="editGreyPanel" style="display:none; margin-top:0.5em;">
					<div id="greyPresets" style="margin-top:0.5em; display:none; gap:8px; flex-wrap:wrap;">
						<button class="presetBtn" data-hex="#808080" style="background:#808080;color:#fff;border:none;padding:6px 8px;border-radius:4px;">Default</button>
						<button class="presetBtn" data-hex="#8c8074" style="background:#8c8074;color:#fff;border:none;padding:6px 8px;border-radius:4px;">Western</button>
						<button class="presetBtn" data-hex="#74808c" style="background:#74808c;color:#fff;border:none;padding:6px 8px;border-radius:4px;">Cool</button>
						<button class="presetBtn" data-hex="#748c77" style="background:#748c77;color:#fff;border:none;padding:6px 8px;border-radius:4px;">Forest</button>
						<!-- newline break disabled: was <div style="flex-basis:100%;height:0"></div> -->
						<button class="presetBtn" data-hex="#8c7480" style="background:#8c7480;color:#fff;border:none;padding:6px 8px;border-radius:4px;">Writrose</button>
						<button class="presetBtn" data-hex="#8c8874" style="background:#8c8874;color:#fff;border:none;padding:6px 8px;border-radius:4px;">Leastdaisy</button>
						<button class="presetBtn" data-hex="#8c7474" style="background:#8c7474;color:#fff;border:none;padding:6px 8px;border-radius:4px;">Springparsley</button>
						<button class="presetBtn" data-hex="#74748c" style="background:#74748c;color:#fff;border:none;padding:6px 8px;border-radius:4px;">Blueberry</button>
						<button class="presetBtn" data-hex="#88748c" style="background:#88748c;color:#fff;border:none;padding:6px 8px;border-radius:4px;">Tiffany</button>
						<button class="presetBtn" data-hex="#878c74" style="background:#878c74;color:#fff;border:none;padding:6px 8px;border-radius:4px;">Grass</button>
					</div>
					<label style="display:flex;align-items:center;gap:8px;">R:
						<input type="range" id="greyR" min="116" max="140" value="128" step="1" style="width:180px;">
						<span id="greyRVal" style="min-width:30px;text-align:center;color:#ccc">128</span>
					</label>
					<label style="display:flex;align-items:center;gap:8px;">G:
						<input type="range" id="greyG" min="116" max="140" value="128" step="1" style="width:180px;">
						<span id="greyGVal" style="min-width:30px;text-align:center;color:#ccc">128</span>
					</label>
					<label style="display:flex;align-items:center;gap:8px;">B:
						<input type="range" id="greyB" min="116" max="140" value="128" step="1" style="width:180px;">
						<span id="greyBVal" style="min-width:30px;text-align:center;color:#ccc">128</span>
					</label>
					<span id="greyPreview" style="display:inline-block;width:40px;height:24px;border:1px solid #666;margin-left:8px;vertical-align:middle;background:#808080"></span>
					<span id="greyHex" style="margin-left:8px;color:#ccc">#808080</span>
				</div>

			</div>

		</div>

		<div id="output" style="max-width:800px;margin:1.5em auto;text-align:center"></div>

		<script>
		// --- JS: controls, applyVHS, flipBits, and handlers ---
		// Setup controls immediately (script is at end of body so DOM elements exist).
		// custom grey used for gens >= 10 (default #808080)
		let customGrey = { r: 128, g: 128, b: 128 };

		function rgbToHex(r,g,b) {
			const toHex = v => (Math.max(0,Math.min(255,Math.round(v))).toString(16).padStart(2,'0'));
			return '#' + toHex(r) + toHex(g) + toHex(b);
		}
	function init() {
			const imgMode = document.getElementById('imgMode');
			const vhsControls = document.getElementById('vhsControls');
			const bitflipControls = document.getElementById('bitflipControls');
			const vhsInput = document.getElementById('vhsInput');
			const vhsInputNum = document.getElementById('vhsInputNum');
			const vhsLabel = document.getElementById('vhsLabel');

			// Ensure the number input's max matches the slider's max to avoid surprises
			try { vhsInputNum.max = vhsInput.max; } catch (e) {}

			imgMode.onchange = function() {
				if (imgMode.value === 'vhs') {
					vhsControls.style.display = '';
					bitflipControls.style.display = 'none';
				} else {
					vhsControls.style.display = 'none';
					bitflipControls.style.display = '';
				}
				updateEditGreyVisibility();
			};

			vhsInput.oninput = function() {
				vhsInputNum.value = vhsInput.value;
				vhsLabel.textContent = vhsInput.value;
				console.debug('vhsInput changed to', vhsInput.value);
				updateEditGreyVisibility();
			};

			vhsInputNum.oninput = function() {
				let val = Math.max(1, Math.min(parseInt(vhsInput.max)||30, parseInt(vhsInputNum.value)||1));
				vhsInput.value = val;
				vhsLabel.textContent = val;
				console.debug('vhsInputNum changed to', val);
				updateEditGreyVisibility();
			};

			// Attach corrupt button handler here too (defensive: ensure single hookup)
			const corruptBtn = document.getElementById('corruptBtn');
			if (corruptBtn && !corruptBtn._hasHandler) {
				corruptBtn._hasHandler = true;
				// leave the main handler defined later; add a tiny log so clicks aren't swallowed
				corruptBtn.addEventListener('click', function(){ console.debug('Corrupt button clicked'); });
			}

			// Edit Grey UI
			const editGreyBtn = document.getElementById('editGreyBtn');
			const editGreyPanel = document.getElementById('editGreyPanel');
			const greyR = document.getElementById('greyR');
			const greyG = document.getElementById('greyG');
			const greyB = document.getElementById('greyB');
			const greyPreview = document.getElementById('greyPreview');
			const greyHex = document.getElementById('greyHex');
			const greyRVal = document.getElementById('greyRVal');
			const greyGVal = document.getElementById('greyGVal');
			const greyBVal = document.getElementById('greyBVal');
			const greyPresets = document.getElementById('greyPresets');

			function hexToRgb(hex) {
				hex = hex.replace('#','');
				if (hex.length === 3) {
					hex = hex.split('').map(h=>h+h).join('');
				}
				const intval = parseInt(hex,16);
				return { r: (intval >> 16) & 255, g: (intval >> 8) & 255, b: intval & 255 };
			}
			const editGreyArea = document.getElementById('editGreyArea');

			function updateEditGreyVisibility() {
				try {
					// Show Edit Grey panel only for VHS mode when generation is 10 through 19 (turn off at 20+)
					const genVal = parseInt(vhsInput.value, 10) || 0;
					const show = (imgMode.value === 'vhs') && (genVal >= 10 && genVal < 20);
					if (editGreyArea) editGreyArea.style.display = show ? '' : 'none';
					if (!show && editGreyPanel) {
						// hide panel and reset to default grey when Edit Grey is not applicable
						editGreyPanel.style.display = 'none';
						customGrey = { r:128, g:128, b:128 };
						if (greyR && greyG && greyB) { greyR.value = 128; greyG.value = 128; greyB.value = 128; }
						if (typeof updateGreyFromInputs === 'function') updateGreyFromInputs();
						if (editGreyBtn) editGreyBtn.textContent = 'Edit Grey';
					}
				} catch (e) { /* ignore during init */ }
			}

			function updateGreyFromInputs() {
				customGrey.r = Math.max(112, Math.min(144, parseInt(greyR.value) || 128));
				customGrey.g = Math.max(112, Math.min(144, parseInt(greyG.value) || 128));
				customGrey.b = Math.max(112, Math.min(144, parseInt(greyB.value) || 128));
				greyPreview.style.background = rgbToHex(customGrey.r, customGrey.g, customGrey.b);
				greyHex.textContent = rgbToHex(customGrey.r, customGrey.g, customGrey.b);
				if (greyRVal) greyRVal.textContent = '' + customGrey.r;
				if (greyGVal) greyGVal.textContent = '' + customGrey.g;
				if (greyBVal) greyBVal.textContent = '' + customGrey.b;
			}

			if (editGreyBtn) {
				editGreyBtn.addEventListener('click', function() {
					// only toggle panel when the whole area is visible
					if (editGreyArea && editGreyArea.style.display === 'none') return;
					// toggle panel
					const nowShown = (editGreyPanel.style.display === 'none');
					editGreyPanel.style.display = nowShown ? '' : 'none';
					// update button text and reset to default when panel hidden
					if (nowShown) {
						editGreyBtn.textContent = 'Unedit Grey';
					} else {
						editGreyBtn.textContent = 'Edit Grey';
						// reset to default grey when not shown
						customGrey = { r:128, g:128, b:128 };
						greyR.value = 128; greyG.value = 128; greyB.value = 128;
						updateGreyFromInputs();
					}
				});
			}
			[greyR, greyG, greyB].forEach(el => {
				if (el) el.addEventListener('input', updateGreyFromInputs);
			});

				// wire preset buttons
				if (greyPresets) {
					greyPresets.querySelectorAll('.presetBtn').forEach(btn => {
						btn.addEventListener('click', function() {
							const hex = btn.getAttribute('data-hex');
							const rgb = hexToRgb(hex);
							// clamp to specified range 112-144 by scaling toward 128
							const clampToRange = v => Math.max(112, Math.min(144, Math.round(v)));
							greyR.value = clampToRange(rgb.r);
							greyG.value = clampToRange(rgb.g);
							greyB.value = clampToRange(rgb.b);
							updateGreyFromInputs();
							// ensure panel is shown and button shows Unedit
							if (editGreyPanel) editGreyPanel.style.display = '';
							if (editGreyBtn) editGreyBtn.textContent = 'Unedit Grey';
						});
					});
				}
			updateGreyFromInputs();
			updateEditGreyVisibility();

            
		}

		init();

			function applyVHS(canvas, ctx, gen, options = {}) {
				const w = canvas.width, h = canvas.height;
				let imgData = ctx.getImageData(0, 0, w, h);
				let data = imgData.data;
				const clamp = v => Math.min(255, Math.max(0, Math.round(v)));

				// 1-3: subtle noise
				if (gen <= 3) {
					for (let i = 0; i < data.length; i += 4) {
						data[i] = clamp(data[i] + (Math.random() - 0.5) * gen * 0.6);
						data[i+1] = clamp(data[i+1] + (Math.random() - 0.5) * gen * 0.6);
						data[i+2] = clamp(data[i+2] + (Math.random() - 0.5) * gen * 0.6);
					}
				}

				// 4-9: progressive smear and colour instability
				if (gen >= 4 && gen < 10) {
					// smear intensity
					const smearFactor = gen < 6 ? 0.85 : (gen < 8 ? 0.7 : 0.6);
					for (let y = 0; y < h; y++) {
						for (let x = 1; x < w; x++) {
							let i = (y * w + x) * 4;
							let prev = (y * w + x - 1) * 4;
							data[i] = clamp(data[i] * smearFactor + data[prev] * (1 - smearFactor));
							data[i+1] = clamp(data[i+1] * smearFactor + data[prev+1] * (1 - smearFactor));
							data[i+2] = clamp(data[i+2] * smearFactor + data[prev+2] * (1 - smearFactor));
						}
					}

					// source snapshot
					const src = new Uint8ClampedArray(data.length);
					src.set(data);

					// generation-tuned params
					let maxShift = 0, noiseScale = 6;
					if (gen === 4 || gen === 5) { maxShift = 1; noiseScale = 6; }
					if (gen === 6) { maxShift = 2; noiseScale = 8; }
					if (gen === 7) { maxShift = 3; noiseScale = 12; }
					if (gen === 8) { maxShift = Math.max(4, Math.min(14, Math.floor(w/40))); noiseScale = 20; }
					if (gen === 9) { maxShift = Math.max(8, Math.min(28, Math.floor(w/30))); noiseScale = 30; }

					for (let y = 0; y < h; y++) {
						// smooth base per-line to create streaking
						const base = Math.sin(y * 0.08 + gen * 0.3) * 0.5;
						const offR = Math.round(base * maxShift + (Math.random() - 0.5) * (maxShift * 0.6));
						const offG = Math.round(base * maxShift * 0.85 + (Math.random() - 0.5) * (maxShift * 0.7));
						const offB = Math.round(base * maxShift * 0.6 + (Math.random() - 0.5) * (maxShift * 0.8));
						for (let x = 0; x < w; x++) {
							let i = (y * w + x) * 4;
							let sxR = Math.min(w-1, Math.max(0, x + offR));
							let sxG = Math.min(w-1, Math.max(0, x + offG));
							let sxB = Math.min(w-1, Math.max(0, x + offB));
							let iR = (y * w + sxR) * 4;
							let iG = (y * w + sxG) * 4;
							let iB = (y * w + sxB) * 4;
							let noise = (Math.random() - 0.5) * noiseScale;
							data[i] = clamp(src[iR] + noise);
							data[i+1] = clamp(src[iG+1] + noise * 0.9);
							data[i+2] = clamp(src[iB+2] + noise * 0.8);

							// higher gens get occasional stronger glitches
							if (gen >= 8 && Math.random() < 0.01) {
								// swap channels for a short burst
								let t = data[i]; data[i] = data[i+2]; data[i+2] = t;
							}

							// gens 7/8/9: if pixel is very different from its neighbours (spatial radius R),
							// fall back to grayscale. Radius: gen7=3, gen8=10, gen9=20.
							if (gen === 7 || gen === 8 || gen === 9) {
								let R = gen === 7 ? 3 : (gen === 8 ? 10 : 20);
								// performance guard: reduce R for very large images
								if (w * h > 1000000) R = Math.max(1, Math.floor(R * 0.5));
								let minY = Math.max(0, y - R), maxY = Math.min(h - 1, y + R);
								let minX = Math.max(0, x - R), maxX = Math.min(w - 1, x + R);
								let sumR = 0, sumG = 0, sumB = 0, count = 0;
								for (let yy = minY; yy <= maxY; yy++) {
									for (let xx = minX; xx <= maxX; xx++) {
										if (yy === y && xx === x) continue;
										let j = (yy * w + xx) * 4;
										sumR += src[j];
										sumG += src[j+1];
										sumB += src[j+2];
										count++;
									}
								}
								if (count > 0) {
									let avgR = sumR / count, avgG = sumG / count, avgB = sumB / count;
									// color distance
									let dr = data[i] - avgR, dg = data[i+1] - avgG, db = data[i+2] - avgB;
									let dist = Math.sqrt(dr*dr + dg*dg + db*db);
									// threshold scales with R
									let threshold = 30 - R * 0.5; // gen7 ~37.5, gen8 ~55, gen9 ~80
									if (dist > threshold) {
										// convert this pixel to grayscale (use luminance of current pixel)
										let lum = Math.round(0.299 * data[i] + 0.587 * data[i+1] + 0.114 * data[i+2]);
										data[i] = data[i+1] = data[i+2] = clamp(lum);
									}
								}
							}
						}
					}
				}

				// 10+: before converting to full mono, optionally apply extra "swivels" made of
				// repeated gen9/gen8-like passes. The user requested:
				// - if gen > 9 and even: (gen-10)/2 swivels of 9, plus 1 swivel of 8
				// - if gen > 9 and odd: (gen-9)/2 swivels of 9
				if (gen >= 10) {
					// helper that performs a single gen8-like or gen9-like pass on `data`
					function doSwivel(level) {
						const src = new Uint8ClampedArray(data.length);
						src.set(data);
						let maxShift = 0, noiseScale = 10;
						if (level === 8) { maxShift = Math.max(4, Math.min(14, Math.floor(w/40))); noiseScale = 20; }
						if (level === 9) { maxShift = Math.max(8, Math.min(28, Math.floor(w/30))); noiseScale = 30; }

						for (let y = 0; y < h; y++) {
							const base = Math.sin(y * 0.08 + level * 0.3) * 0.5;
							const offR = Math.round(base * maxShift + (Math.random() - 0.5) * (maxShift * 0.6));
							const offG = Math.round(base * maxShift * 0.85 + (Math.random() - 0.5) * (maxShift * 0.7));
							const offB = Math.round(base * maxShift * 0.6 + (Math.random() - 0.5) * (maxShift * 0.8));
							for (let x = 0; x < w; x++) {
								let i = (y * w + x) * 4;
								let sxR = Math.min(w-1, Math.max(0, x + offR));
								let sxG = Math.min(w-1, Math.max(0, x + offG));
								let sxB = Math.min(w-1, Math.max(0, x + offB));
								let iR = (y * w + sxR) * 4;
								let iG = (y * w + sxG) * 4;
								let iB = (y * w + sxB) * 4;
								let noise = (Math.random() - 0.5) * noiseScale;
								data[i] = clamp(src[iR] + noise);
								data[i+1] = clamp(src[iG+1] + noise * 0.9);
								data[i+2] = clamp(src[iB+2] + noise * 0.8);
								if (level >= 9 && Math.random() < 0.01) {
									let t = data[i]; data[i] = data[i+2]; data[i+2] = t;
								}
							}
						}
					}

					// compute counts
					let swivels9 = 0, swivels8 = 0;
					if (gen % 2 === 0) {
						swivels9 = Math.floor((gen - 10) / 2);
						swivels8 = 1; // 1 - (gen % 2) -> when even this becomes 1
					} else {
						swivels9 = Math.floor((gen - 9) / 2);
						swivels8 = 0;
					}

					// defer applying swivels until after the mono/noise/blur pass
					for (let i = 0; i < data.length; i += 4) {
						// compute luminance and normalized L
						let r = data[i], g = data[i+1], b = data[i+2];
						let lum = 0.299 * r + 0.587 * g + 0.114 * b;
						let L = lum / 255;
						let noise = (Math.random()-0.5) * Math.pow((gen-9), 2) * 4;
						let rf, gf, bf;
						if (L <= 0.5) {
							// dark pixels: blend between black and custom grey
							let wGrey = 2 * L; // 0 -> fully black, 1 -> fully grey
							rf = wGrey * customGrey.r;
							gf = wGrey * customGrey.g;
							bf = wGrey * customGrey.b;
						} else {
							// light pixels: blend between white and custom grey
							let wWhite = 2 * L - 1; // 0 -> fully grey, 1 -> fully white
							let wGrey = 1 - wWhite;
							rf = wWhite * 255 + wGrey * customGrey.r;
							gf = wWhite * 255 + wGrey * customGrey.g;
							bf = wWhite * 255 + wGrey * customGrey.b;
						}
						data[i] = clamp(rf + noise);
						data[i+1] = clamp(gf + noise);
						data[i+2] = clamp(bf + noise);
					}
					for (let y = 1; y < h-1; y++) {
						for (let x = 1; x < w-1; x++) {
							let i = (y * w + x) * 4;
							for (let c = 0; c < 3; c++) {
								let sum = data[i+c] + data[i+c-4] + data[i+c+4] + data[i+c-w*4] + data[i+c+w*4];
								data[i+c] = clamp(sum / 5);
							}
						}
					}

					// finally, apply swivels to the final image so they remain visible after mono/blur
					for (let i = 0; i < swivels9; i++) doSwivel(9);
					for (let i = 0; i < swivels8; i++) doSwivel(8);
				}

				// finish
				ctx.putImageData(imgData, 0, 0);
			}

		function flipBits(buffer, percent) {
			const totalBits = buffer.byteLength * 8;
			const bitsToFlip = Math.floor(totalBits * (percent / 100));
			const view = new Uint8Array(buffer);
			const flipped = new Set();
			while (flipped.size < bitsToFlip) {
				const bitIndex = Math.floor(Math.random() * totalBits);
				if (flipped.has(bitIndex)) continue;
				flipped.add(bitIndex);
				const byteIndex = Math.floor(bitIndex / 8);
				const bitInByte = bitIndex % 8;
				view[byteIndex] ^= (1 << bitInByte);
			}
			return buffer;
		}

		document.getElementById('corruptBtn').onclick = async function() {
			const fileInput = document.getElementById('fileInput');
			const percent = parseFloat(document.getElementById('percentInput').value);
			const vhsGen = parseInt(document.getElementById('vhsInput').value);
			const output = document.getElementById('output');
			output.innerHTML = '';

			let file = fileInput.files[0];
			let corruptedBuffer, blob, url, ext, type;

			if (file) {
				const name = file.name.toLowerCase();
				if (name.match(/\.(png|jpg|jpeg)$/)) {
					const imgMode = document.getElementById('imgMode').value;
					if (imgMode === 'vhs') {
						const img = new Image();
						img.onload = function() {
							const canvas = document.createElement('canvas');
							canvas.width = img.width;
							canvas.height = img.height;
							const ctx = canvas.getContext('2d');
							ctx.drawImage(img, 0, 0);
							applyVHS(canvas, ctx, vhsGen);
							canvas.toBlob(function(blob) {
								const url = URL.createObjectURL(blob);
								const outImg = document.createElement('img');
								outImg.src = url;
								outImg.alt = 'VHS simulated image';
								output.appendChild(outImg);
								const dl = document.createElement('a');
								dl.href = url;
								dl.download = 'vhs_' + file.name;
								dl.textContent = 'Download VHS simulated image';
								dl.style.display = 'block';
								dl.style.marginTop = '1em';
								output.appendChild(dl);
							}, file.type || 'image/png');
						};
						img.onerror = function() { output.textContent = 'Could not load image.'; };
						img.src = URL.createObjectURL(file);
						return;
					} else {
						const reader = new FileReader();
						reader.onload = function(e) {
							const arrayBuffer = e.target.result;
							const percent = parseFloat(document.getElementById('percentInput').value);
							let attempts = 0;
							let lastUrl = null;

							function tryOnce() {
								attempts++;
								// create a fresh corrupted copy for each attempt
								const corruptedBuffer = flipBits(arrayBuffer.slice(0), percent);
								const blob = new Blob([corruptedBuffer], {type: file.type || 'image/png'});
								const url = URL.createObjectURL(blob);

								const testImg = new Image();
								testImg.onload = function() {
									// success: revoke previous failed URL, keep current for download/preview
									if (lastUrl && lastUrl !== url) try { URL.revokeObjectURL(lastUrl); } catch (err) {}
									const outImg = document.createElement('img');
									outImg.src = url;
									outImg.alt = 'Bit-flip corrupted image';
									output.appendChild(outImg);
									const dl = document.createElement('a');
									dl.href = url;
									dl.download = 'bitflip_' + file.name;
									dl.textContent = 'Download bit-flip corrupted image';
									dl.style.display = 'block';
									dl.style.marginTop = '1em';
									output.appendChild(dl);
								};
								testImg.onerror = function() {
									// failed to load as image; revoke this url and retry up to 100 times
									try { URL.revokeObjectURL(url); } catch (err) {}
									if (attempts < 100) {
										// small delay to avoid locking event loop
										setTimeout(tryOnce, 0);
									} else {
										output.textContent = 'Could not produce a valid image after 100 attempts.';
									}
								};

								lastUrl = url;
								// trigger load attempt
								testImg.src = url;
							}

							tryOnce();
						};
						reader.onerror = function() { output.textContent = 'Could not read image.'; };
						reader.readAsArrayBuffer(file);
						return;
					}
				} else if (name.match(/\.(mp3|wav|ogg|flac|aac)$/)) {
					const arrayBuffer = await file.arrayBuffer();
					corruptedBuffer = flipBits(arrayBuffer.slice(0), percent);
					blob = new Blob([corruptedBuffer], {type: file.type || 'audio/mpeg'});
					url = URL.createObjectURL(blob);
					type = 'audio';
					ext = name.split('.').pop();
				} else if (name.match(/\.(mp4|webm|ogg|avi|mov|mkv)$/)) {
					const arrayBuffer = await file.arrayBuffer();
					corruptedBuffer = flipBits(arrayBuffer.slice(0), percent);
					blob = new Blob([corruptedBuffer], {type: file.type || 'video/mp4'});
					url = URL.createObjectURL(blob);
					type = 'video';
					ext = name.split('.').pop();
				} else {
					output.textContent = 'File must be an image, audio, or video file.';
					return;
				}
			} else {
				output.textContent = 'Please select an image, audio, or video file.';
				return;
			}

			if (type === 'image') {
				const img = document.createElement('img');
				img.src = url;
				img.alt = 'Corrupted PNG';
				output.appendChild(img);
				const dl = document.createElement('a');
				dl.href = url;
				dl.download = 'corrupted.' + ext;
				dl.textContent = 'Download corrupted PNG';
				dl.style.display = 'block';
				dl.style.marginTop = '1em';
				output.appendChild(dl);
			} else if (type === 'audio') {
				const audio = document.createElement('audio');
				audio.controls = true;
				audio.src = url;
				output.appendChild(audio);
				const dl = document.createElement('a');
				dl.href = url;
				dl.download = 'corrupted.' + ext;
				dl.textContent = 'Download corrupted audio';
				dl.style.display = 'block';
				dl.style.marginTop = '1em';
				output.appendChild(dl);
			} else if (type === 'video') {
				const video = document.createElement('video');
				video.controls = true;
				video.src = url;
				video.style.maxWidth = '100%';
				output.appendChild(video);
				const dl = document.createElement('a');
				dl.href = url;
				dl.download = 'corrupted.' + ext;
				dl.textContent = 'Download corrupted video';
				dl.style.display = 'block';
				dl.style.marginTop = '1em';
				output.appendChild(dl);
			}
		};
		</script>
