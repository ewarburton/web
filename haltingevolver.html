<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Halting BF Evolver</title>
    <style>
        body { font-family: monospace; background: #222; color: #eee; transition: background 0.3s, color 0.3s; }
        .log { white-space: pre; background: #111; padding: 1em; border-radius: 8px; }
        button {
            margin: 1em 0;
            background: inherit;
            border: 2px solid #eee;
            transition: background 0.3s, color 0.3s, border-color 0.3s;
        }
        #bgcolor { width: 120px; }
        .program-text {
            padding: 0 2px;
            border-radius: 2px;
            color: #fff !important;
            background: var(--program-bg, #000);
            box-sizing: border-box;
        }
    </style>
</head>
<body>
    <h1>Halting BF Evolver</h1>
    <button id="run">Run 50 Generations</button>
    <button id="run-until-stop">Run Until Stop</button>
    <label for="init-length-input" style="margin-left:1em;">Initial Program Length</label>
    <input type="number" id="init-length-input" min="1" value="5" style="width:5em;" title="Initial program length" />

    <input type="number" id="run-until-length-input" min="1" value="50" style="width:5em;" title="Target length" />

        <button id="run-until-length">Run Until Length</button>
    <button id="stop">Stop</button>
    <button id="reset">Reset</button>
    <input type="color" id="bgcolor" value="#222222" title="Background color" />
    <label for="bgcolor">Background</label>
    <div id="champion" style="margin:1em 0; padding:0.5em; border-radius:6px; font-family:monospace;"></div>
    <div class="log" id="log"></div>
    <script>
let runUntilLengthTarget = null; // Moved variable declaration to script section
// --- Background color and text color logic ---
function setBgAndTextColor(hex) {
    document.body.style.background = hex;
    // Parse hex to r,g,b in [0,1]
    let r = parseInt(hex.substr(1,2),16)/255;
    let g = parseInt(hex.substr(3,2),16)/255;
    let b = parseInt(hex.substr(5,2),16)/255;
    let brightness = r*0.5 + g*0.8 + b*0.2;
    let fg = (brightness > 0.75) ? '#000' : '#fff';
    document.body.style.color = fg;
    let logDiv = document.getElementById('log');
    if (logDiv) logDiv.style.color = fg;
    // Button text matches main text, background matches page, border matches text
    document.querySelectorAll('button').forEach(el => {
        el.style.color = fg;
        el.style.background = hex;
        el.style.borderColor = fg;
    });
    document.querySelectorAll('label').forEach(el => el.style.color = fg);
}

window.addEventListener('DOMContentLoaded', function() {
    const colorInput = document.getElementById('bgcolor');
    setBgAndTextColor(colorInput.value);
    colorInput.addEventListener('input', e => setBgAndTextColor(e.target.value));
    // Always show champion area with default message
    const championDiv = document.getElementById('champion');
    championDiv.innerHTML =
        '<b>Champion:</b> <span style="color:#fff">(none yet)</span><br>' +
        '<b>Steps:</b> <br>' +
        '<b>Output:</b> <span style="color:#fff"></span>';
});
    </script>
    <script>
// --- Brainfuck Interpreter ---
function runBF(code, maxSteps = 10000000) {
    const tape = new Uint8Array(30000);
    let ptr = 0, ip = 0, steps = 0;
    const stack = [];
    let output = '';
    while (ip < code.length && steps < maxSteps) {
        switch (code[ip]) {
            case '>': ptr++; break;
            case '<': ptr--; break;
            case '+': tape[ptr]++; break;
            case '-': tape[ptr]--; break;
            case '.': output += String.fromCharCode(tape[ptr]); break;
            // case ',': break; // removed ','
            case '[':
                if (tape[ptr] === 0) {
                    let open = 1;
                    while (open && ++ip < code.length) {
                        if (code[ip] === '[') open++;
                        if (code[ip] === ']') open--;
                    }
                } else {
                    stack.push(ip);
                }
                break;
            case ']':
                if (tape[ptr] !== 0) {
                    ip = stack[stack.length - 1];
                } else {
                    stack.pop();
                }
                break;
        }
        ip++;
        steps++;
    }
    return {halting: ip >= code.length, steps, output};
}

// --- Random BF Program Generator ---
function randomBF(len) {
    const chars = ['>', '<', '+', '-', '.', '[', ']']; // removed ','
    let s = '';
    for (let i = 0; i < len; i++) s += chars[Math.floor(Math.random() * chars.length)];
    return s;
}

// --- Mutate BF Program ---
function mutateBF(code) {
    const chars = ['>', '<', '+', '-', '.', '[', ']']; // removed ','
    let arr = code.split('');
    // random mutation: insert, delete, or change
    const r = Math.random();
    if (r < 0.33 && arr.length > 1) {
        arr.splice(Math.floor(Math.random() * arr.length), 1); // delete
    } else if (r < 0.66) {
        arr.splice(Math.floor(Math.random() * (arr.length + 1)), 0, chars[Math.floor(Math.random() * chars.length)]); // insert
    } else {
        arr[Math.floor(Math.random() * arr.length)] = chars[Math.floor(Math.random() * chars.length)]; // change
    }
    return arr.join('');
}

// --- Evolutionary Loop ---
let stopEvolution = false;
let evoState = null;
function evolve(log, gens = 50) {
    stopEvolution = false;
    if (!evoState) {
        // initialize
        let population = [];
        for (let i = 0; i < 10; i++) population.push(randomBF(10 + Math.floor(Math.random() * 10)));
        let evals = population.map(p => ({code: p, ...runBF(p)}));
        let halting = evals.filter(e => e.halting);
        let parent;
        if (halting.length > 0) {
            parent = halting[Math.floor(Math.random() * halting.length)].code;
            log('Initial halting found.');
        } else {
            parent = evals[Math.floor(Math.random() * evals.length)].code;
            log('No halting program found, picking random.');
        }
        log('Initial parent: ' + parent);
        evoState = {parent, gen: 1};
    }
    let stepsLeft = gens;
    // Champion display updater
    const championDiv = document.getElementById('champion');
    function updateChampionDisplay(code, steps, output) {
        // If running in Run Until Length mode, check if champion is long enough
        if (runUntilLengthTarget && code && code.length >= runUntilLengthTarget) {
            stopEvolution = true;
        }
        // Use the same showOutput as below
        function showOutput(str) {
            return Array.from(str, c => {
                const code = c.charCodeAt(0);
                if (code < 32) {
                    // U+2400 to U+241F: Control Pictures
                    return String.fromCharCode(0x2400 + code);
                }
                else if (code === 127) {
                    return String.fromCharCode(0x247F); // U+247F: Circled Number 0
                }
                else {
                    return c;
                }
            }).join('');
        }
        championDiv.innerHTML =
            `<b>Champion:</b> <span>${code}</span><br>` +
            `<b>Steps:</b> ${steps}<br>` +
            `<b>Output:</b> <span>${showOutput(output)}</span>`;
    }
    function step() {
        if (stopEvolution) { log('Stopped.'); return; }
        let children = [];
        for (let i = 0; i < 10; i++) children.push(mutateBF(evoState.parent));
        let evals = children.map(p => ({code: p, ...runBF(p)}));
        let halting = evals.filter(e => e.halting);
        let next, steps = null, chosenIdx = null;
        if (halting.length > 0) {
            if (evoState.gen > 5) {
                let best = halting.reduce((a, b) => {
                    let scoreA = a.steps - (a.code.length / 2);
                    let scoreB = b.steps - (b.code.length / 2);
                    return scoreB > scoreA ? b : a;
                });
                next = best.code;
                steps = best.steps;
                // find index in evals
                chosenIdx = evals.findIndex(e => e.code === next);
                log(`Gen ${evoState.gen}: Halting found, steps ${steps}, length ${next.length}`);
                updateChampionDisplay(next, steps, best.output);
            } else {
                // pick random halting for first 5 gens
                let chosen = halting[Math.floor(Math.random() * halting.length)];
                next = chosen.code;
                steps = chosen.steps;
                chosenIdx = evals.findIndex(e => e.code === next);
                log(`Gen ${evoState.gen}: Halting found, steps ${steps}, length ${next.length}`);
                updateChampionDisplay(next, steps, chosen.output);
            }
        } else {
            let idx = Math.floor(Math.random() * evals.length);
            next = evals[idx].code;
            chosenIdx = idx;
            log(`Gen ${evoState.gen}: No halting, picking random.`);
            updateChampionDisplay(next, null, evals[idx].output);
        }
        log('All programs:');
        evals.forEach((e, i) => {
            // Helper to show non-printable chars as Unicode U+24XX (circled letters/numbers)
            function showOutput(str) {
                return Array.from(str, c => {
                    const code = c.charCodeAt(0);
                    if (code < 32) {
                        // U+2400 to U+241F: Control Pictures
                        return String.fromCharCode(0x2400 + code);
                    }
                    else if (code === 127) {
                        return String.fromCharCode(0x247F); // U+247F: Circled Number 0
                    }
                    else {
                        return c;
                    }
                }).join('');
            }
            log(`  ${i+1}: ${e.code} ${e.halting ? `(halting, steps ${e.steps}, output length ${e.output.length}, output: "${showOutput(e.output)}")` : ''}`);
        });
        log('Chosen program: ' + next + (chosenIdx !== null ? ` (#${chosenIdx+1})` : ''));

        evoState.parent = next;
        evoState.gen++;
        stepsLeft--;
        if (stepsLeft > 0) setTimeout(step, 100);
    }
    setTimeout(step, 100);
}

document.getElementById('run').onclick = function() {
    const logDiv = document.getElementById('log');
    function logFn(msg) {
        // Always wrap the log line in a .program-text span for consistent styling
        const html = `<span class='program-text'>${msg.replace(/</g, '&lt;').replace(/>/g, '&gt;')}</span><br>`;
        logDiv.innerHTML += html;
    }
    evolve(logFn, 50);
};

document.getElementById('run-until-stop').onclick = function() {
    const logDiv = document.getElementById('log');
    function logFn(msg) {
        const html = `<span class='program-text'>${msg.replace(/</g, '&lt;').replace(/>/g, '&gt;')}</span><br>`;
        logDiv.innerHTML += html;
    }
    // Use a very large number for generations to simulate 'infinite' run
    evolve(logFn, 1000000000);
};
document.getElementById('run-until-length').onclick = function() {
    const logDiv = document.getElementById('log');
    const input = document.getElementById('run-until-length-input');
    runUntilLengthTarget = parseInt(input.value, 10) || 1;
    function logFn(msg) {
        const html = `<span class='program-text'>${msg.replace(/</g, '&lt;').replace(/>/g, '&gt;')}</span><br>`;
        logDiv.innerHTML += html;
    }
    evolve(logFn, 1000000000);
};

document.getElementById('stop').onclick = function() {
    stopEvolution = true;
    runUntilLengthTarget = null;
};
document.getElementById('reset').onclick = function() {
    const logDiv = document.getElementById('log');
    logDiv.textContent = '';
    evoState = null;
    runUntilLengthTarget = null;
};
    </script>
</body>
</html>
