<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Microtonal Lattice</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: 'Courier New', monospace;
            background: #111;
            color: #fff;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        #controls {
            background: #222;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            width: 90%;
            max-width: 800px;
        }
        
        .control-group {
            margin: 15px 0;
            display: flex;
            align-items: center;
            gap: 15px;
        }
        
        label {
            min-width: 120px;
            font-weight: bold;
        }
        
        input[type="number"],
        input[type="text"] {
            background: #333;
            border: 1px solid #555;
            color: #fff;
            padding: 8px;
            border-radius: 4px;
            width: 120px;
            font-family: 'Courier New', monospace;
        }
        
        input[type="number"]:focus,
        input[type="text"]:focus {
            outline: none;
            border-color: #0af;
        }
        
        button {
            background: #0af;
            border: none;
            color: #000;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            font-family: 'Courier New', monospace;
        }
        
        button:hover {
            background: #0cf;
        }
        
        canvas {
            border: 2px solid #333;
            background: #000;
            cursor: crosshair;
        }
        
        #info {
            margin-top: 15px;
            padding: 15px;
            background: #222;
            border-radius: 8px;
            min-height: 60px;
            width: 90%;
            max-width: 800px;
        }
        
        .preset-buttons {
            display: flex;
            gap: 10px;
            margin-top: 10px;
            flex-wrap: wrap;
        }
        
        .preset-buttons button {
            background: #555;
            font-size: 12px;
            padding: 6px 12px;
        }
        
        .preset-buttons button:hover {
            background: #777;
        }
    </style>
</head>
<body>
    <h1>Microtonal Lattice Explorer</h1>
    
    <div id="controls">
        <div class="control-group">
            <label for="xCents">X-Axis:</label>
            <input type="text" id="xCents" value="3/2F" placeholder="cents or X/YF">
            <span class="note-name">Perfect Fifth</span>
        </div>
        
        <div class="control-group">
            <label for="yCents">Y-Axis:</label>
            <input type="text" id="yCents" value="5/4F" placeholder="cents or X/YF">
            <span class="note-name">Major Third</span>
        </div>
        
        <div class="control-group">
            <label for="gridSize">Grid Size:</label>
            <input type="number" id="gridX" value="9" min="1" max="20" style="width: 60px;"> x
            <input type="number" id="gridY" value="9" min="1" max="20" style="width: 60px;">
            <span style="font-size: 12px;">(X by Y from center)</span>
        </div>
        
        <div class="control-group">
            <button onclick="updateLattice()">Update Lattice</button>
            <button onclick="resetToDefaults()">Reset to 5-limit JI</button>
            <button onclick="toggleOctaveReduction()">Reduce to Octave</button>
        </div>
        
        <div class="preset-buttons">
            <button onclick="setPreset('5limit')">5-limit JI</button>
            <button onclick="setPreset('pythagorean')">Pythagorean</button>
            <button onclick="setPreset('7limit')">7-limit JI</button>
            <button onclick="setPreset('12edo')">12-EDO</button>
            <button onclick="setPreset('31edo')">31-EDO</button>
            <button onclick="setPreset('53edo')">53-EDO</button>
        </div>
    </div>
    
    <canvas id="lattice" width="900" height="900"></canvas>
    
    <div id="info">
        Hover over nodes to see pitch information. Click to hear the tone.
    </div>

    <script>
        const canvas = document.getElementById('lattice');
        const ctx = canvas.getContext('2d');
        let gridSizeX = 9; // X units from center
        let gridSizeY = 9; // Y units from center
        const nodeRadius = 8;
        const spacing = 45;
        
        let xCents = 701.955; // Perfect fifth (3/2)
        let yCents = 386.314; // Major third (5/4)
        let xRatio = 3/2; // Store exact ratio
        let yRatio = 5/4; // Store exact ratio
        let hoveredNode = null;
        let audioContext = null;
        let isOctaveReduced = false; // Track if we're in octave-reduced mode
        
        // Keyboard to lattice offset mapping
        const keyMap = {
            'd': [0, 0],   // touching
            'e': [0, 1],   // y up
            'c': [0, -1],  // y down
            'f': [1, 0],   // x up
            's': [-1, 0],  // x down
            'r': [1, 1],   // x+y
            'z': [-2, -1], // -2x-y
            '7': [4, 2],   // 4x+2y
            
            // Grid mapping (keyboard layout as lattice)
            '1': [-2, 2], '2': [-1, 2], '3': [0, 2], '4': [1, 2], '5': [2, 2], '6': [3, 2],
            'q': [-2, 1], 'w': [-1, 1], 't': [2, 1], 'y': [3, 1], 'u': [4, 1],
            'a': [-2, 0], 'g': [2, 0], 'h': [3, 0], 'j': [4, 0],
            'x': [-1, -1], 'v': [1, -1], 'b': [2, -1], 'n': [3, -1], 'm': [4, -1]
        };
        
        // Presets
        const presets = {
            '5limit': { x: '3/2F', y: '5/4F', name: '5-limit JI (3/2, 5/4)' },
            'pythagorean': { x: '3/2F', y: '3/2F', name: 'Pythagorean (3/2, 3/2)' },
            '7limit': { x: '3/2F', y: '7/4F', name: '7-limit JI (3/2, 7/4)' },
            '12edo': { x: '700', y: '400', name: '12-EDO approx' },
            '31edo': { x: '696.774', y: '387.097', name: '31-EDO' },
            '53edo': { x: '701.887', y: '384.906', name: '53-EDO' }
        };
        
        function initAudioContext() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
        }
        
        function centsToRatio(cents) {
            return Math.pow(2, cents / 1200);
        }
        
        function getPrimeFactors(n) {
            const factors = [];
            let num = n;
            for (let i = 2; i <= num; i++) {
                while (num % i === 0) {
                    factors.push(i);
                    num /= i;
                }
            }
            return factors;
        }
        
        function getUsedPrimes() {
            // Get prime factors from the current axis ratios
            const primes = new Set([2]); // Always include 2 for octaves
            
            // Add primes from xRatio
            const xFrac = ratioToSimpleFraction(xRatio);
            if (xFrac) {
                getPrimeFactors(xFrac.numer).forEach(p => primes.add(p));
                getPrimeFactors(xFrac.denom).forEach(p => primes.add(p));
            }
            
            // Add primes from yRatio
            const yFrac = ratioToSimpleFraction(yRatio);
            if (yFrac) {
                getPrimeFactors(yFrac.numer).forEach(p => primes.add(p));
                getPrimeFactors(yFrac.denom).forEach(p => primes.add(p));
            }
            
            return primes;
        }
        
        function ratioToSimpleFraction(ratio, maxDenom = 1000) {
            // Find simple fraction for a ratio
            for (let denom = 1; denom <= maxDenom; denom++) {
                const numer = Math.round(ratio * denom);
                if (Math.abs(numer / denom - ratio) < 1e-10) {
                    return { numer, denom };
                }
            }
            return null;
        }
        
        function onlyUsesAllowedPrimes(numer, denom, allowedPrimes) {
            const numerPrimes = getPrimeFactors(numer);
            const denomPrimes = getPrimeFactors(denom);
            const allPrimes = [...numerPrimes, ...denomPrimes];
            
            return allPrimes.every(p => allowedPrimes.has(p));
        }
        
        function gcd(a, b) {
            return b === 0 ? a : gcd(b, a % b);
        }
        
        function findApproxFraction(ratio, maxDenom = 1000) {
            // Find best fraction approximation without prime restrictions
            for (let denom = 1; denom <= maxDenom; denom++) {
                const numer = Math.round(ratio * denom);
                if (Math.abs(numer / denom - ratio) < 1e-9) {
                    const g = gcd(numer, denom);
                    return { numer: numer / g, denom: denom / g };
                }
            }
            return null;
        }
        
        function getFractionForNode(x, y, distance) {
            // Get base fractions for x and y axes
            const xFrac = ratioToSimpleFraction(xRatio);
            const yFrac = ratioToSimpleFraction(yRatio);
            
            if (!xFrac || !yFrac) return null;
            
            // Calculate numerator and denominator separately
            // ratio = (xNumer/xDenom)^x * (yNumer/yDenom)^y
            // Start with 1/1
            let numer = 1;
            let denom = 1;
            
            // Handle x exponent
            if (x > 0) {
                numer *= Math.pow(xFrac.numer, x);
                denom *= Math.pow(xFrac.denom, x);
            } else if (x < 0) {
                numer *= Math.pow(xFrac.denom, -x);
                denom *= Math.pow(xFrac.numer, -x);
            }
            
            // Handle y exponent
            if (y > 0) {
                numer *= Math.pow(yFrac.numer, y);
                denom *= Math.pow(yFrac.denom, y);
            } else if (y < 0) {
                numer *= Math.pow(yFrac.denom, -y);
                denom *= Math.pow(yFrac.numer, -y);
            }
            
            // Round to handle floating point errors
            numer = Math.round(numer);
            denom = Math.round(denom);
            
            // Only reduce with GCD if distance < 5
            if (distance < 5) {
                const g = gcd(numer, denom);
                numer /= g;
                denom /= g;
            }
            
            return { numer, denom };
        }
        
        function parseInput(input) {
            // Check if input is in X/YF format
            const ratioMatch = input.trim().match(/^(\d+)\/(\d+)F$/i);
            if (ratioMatch) {
                const ratio = parseInt(ratioMatch[1]) / parseInt(ratioMatch[2]);
                const cents = 1200 * Math.log2(ratio);
                return { ratio, cents };
            }
            
            // Check if input is in XF format (whole number ratio)
            const wholeMatch = input.trim().match(/^(\d+\.?\d*)F$/i);
            if (wholeMatch) {
                const ratio = parseFloat(wholeMatch[1]);
                const cents = 1200 * Math.log2(ratio);
                return { ratio, cents };
            }
            
            // Otherwise treat as cents
            const cents = parseFloat(input);
            const ratio = centsToRatio(cents);
            return { ratio, cents };
        }
        
        function playTone(cents, duration = 0.5) {
            initAudioContext();
            
            // Apply octave reduction if enabled
            const playbackCents = isOctaveReduced ? ((cents % 1200) + 1200) % 1200 : cents;
            
            const baseFreq = 261.63; // Middle C
            const frequency = baseFreq * centsToRatio(playbackCents);
            
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.frequency.value = frequency;
            oscillator.type = 'sine';
            
            gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + duration);
        }
        
        function getCentsForNode(x, y) {
            // Calculate exact ratio first, then convert to cents
            const ratio = Math.pow(xRatio, x) * Math.pow(yRatio, y);
            return 1200 * Math.log2(ratio);
        }
        
        function getScreenPos(x, y) {
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            return {
                x: centerX + x * spacing,
                y: centerY - y * spacing // Invert Y for screen coordinates
            };
        }
        
        function drawLattice() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw grid lines
            ctx.strokeStyle = '#222';
            ctx.lineWidth = 1;
            
            for (let x = -gridSizeX; x <= gridSizeX; x++) {
                for (let y = -gridSizeY; y <= gridSizeY; y++) {
                    const pos = getScreenPos(x, y);
                    
                    // Draw connections
                    if (x < gridSizeX) {
                        const rightPos = getScreenPos(x + 1, y);
                        ctx.beginPath();
                        ctx.moveTo(pos.x, pos.y);
                        ctx.lineTo(rightPos.x, rightPos.y);
                        ctx.stroke();
                    }
                    
                    if (y < gridSizeY) {
                        const upPos = getScreenPos(x, y + 1);
                        ctx.beginPath();
                        ctx.moveTo(pos.x, pos.y);
                        ctx.lineTo(upPos.x, upPos.y);
                        ctx.stroke();
                    }
                }
            }
            
            // Draw nodes
            for (let x = -gridSizeX; x <= gridSizeX; x++) {
                for (let y = -gridSizeY; y <= gridSizeY; y++) {
                    const pos = getScreenPos(x, y);
                    const cents = getCentsForNode(x, y);
                    const octaveReduced = ((cents % 1200) + 1200) % 1200;
                    const ratio = centsToRatio(cents);
                    const distance = Math.sqrt(x * x + y * y);
                    
                    // Color based on position
                    let hue = octaveReduced / 1200 * 360;
                    let saturation = 70;
                    let lightness = 50;
                    
                    const squareSize = 50;
                    
                    // Highlight origin
                    if (x === 0 && y === 0) {
                        ctx.fillStyle = '#fff';
                        ctx.strokeStyle = '#0af';
                        ctx.lineWidth = 3;
                    } else if (hoveredNode && hoveredNode.x === x && hoveredNode.y === y) {
                        ctx.fillStyle = `hsl(${hue}, ${saturation}%, ${lightness + 20}%)`;
                        ctx.strokeStyle = '#fff';
                        ctx.lineWidth = 2;
                    } else {
                        ctx.fillStyle = `hsl(${hue}, ${saturation}%, ${lightness}%)`;
                        ctx.strokeStyle = `hsl(${hue}, ${saturation}%, ${lightness - 20}%)`;
                        ctx.lineWidth = 1;
                    }
                    
                    // Draw square
                    ctx.beginPath();
                    ctx.rect(pos.x - squareSize/2, pos.y - squareSize/2, squareSize, squareSize);
                    ctx.fill();
                    ctx.stroke();
                    
                    // Draw text
                    ctx.fillStyle = '#000';
                    ctx.font = 'bold 8px Courier New';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    
                    // Format ratio
                    let ratioText;
                    const frac = getFractionForNode(x, y, distance);
                    
                    if (frac && frac.denom === 1) {
                        ratioText = `${frac.numer}F`;
                    } else if (frac) {
                        ratioText = `${frac.numer}/${frac.denom}F`;
                    } else {
                        // Show decimal when no valid fraction exists
                        ratioText = `${ratio.toFixed(3)}F`;
                    }
                    
                    // Check if we need to split the fraction across lines
                    const needsMultiLine = frac && (
                        (frac.numer.toString().length >= 4) ||
                        (frac.numer.toString().length >= 3 && frac.denom.toString().length >= 3)
                    );
                    
                    if (needsMultiLine) {
                        // Draw numerator on top line
                        ctx.fillText(`${frac.numer}`, pos.x, pos.y - 8);
                        // Draw /denominator on bottom line
                        ctx.fillText(`/${frac.denom}F`, pos.x, pos.y + 2);
                    } else {
                        // Draw ratio on single top line
                        ctx.fillText(ratioText, pos.x, pos.y - 8);
                    }
                    
                    // Draw cents on bottom line
                    ctx.font = '8px Courier New';
                    ctx.fillText(`${Math.round(octaveReduced)}¢`, pos.x, pos.y + 12);
                }
            }
        }
        
        function getNodeAtPosition(mouseX, mouseY) {
            for (let x = -gridSizeX; x <= gridSizeX; x++) {
                for (let y = -gridSizeY; y <= gridSizeY; y++) {
                    const pos = getScreenPos(x, y);
                    const dx = mouseX - pos.x;
                    const dy = mouseY - pos.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance <= nodeRadius + 5) {
                        return { x, y, cents: getCentsForNode(x, y) };
                    }
                }
            }
            return null;
        }
        
        function updateInfo(node) {
            const info = document.getElementById('info');
            if (node) {
                const octaveReduced = ((node.cents % 1200) + 1200) % 1200;
                const octave = Math.floor(node.cents / 1200);
                const ratio = centsToRatio(node.cents);
                
                info.innerHTML = `
                    <strong>Position:</strong> (${node.x}, ${node.y})<br>
                    <strong>Cents:</strong> ${node.cents.toFixed(3)}¢ 
                    (${octaveReduced.toFixed(3)}¢ + ${octave} octaves)<br>
                    <strong>Ratio from C:</strong> ${ratio.toFixed(6)}:1
                `;
            } else {
                info.innerHTML = 'Hover over nodes to see pitch information. Click to hear the tone.<br>' +
                    '<strong>Keys:</strong> Press letter/number keys to play notes relative to hovered position (e.g., D=current, E=+Y, F=+X, R=+X+Y, 7=+4X+2Y)';
            }
        }
        
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
            hoveredNode = getNodeAtPosition(mouseX, mouseY);
            updateInfo(hoveredNode);
            drawLattice();
        });
        
        canvas.addEventListener('click', (e) => {
            if (hoveredNode) {
                playTone(hoveredNode.cents);
            }
        });
        
        canvas.addEventListener('mouseleave', () => {
            hoveredNode = null;
            updateInfo(null);
            drawLattice();
        });
        
        function updateLattice() {
            const xInput = parseInput(document.getElementById('xCents').value);
            const yInput = parseInput(document.getElementById('yCents').value);
            
            xCents = xInput.cents;
            yCents = yInput.cents;
            xRatio = xInput.ratio;
            yRatio = yInput.ratio;
            
            // Update grid size
            gridSizeX = parseInt(document.getElementById('gridX').value) || 9;
            gridSizeY = parseInt(document.getElementById('gridY').value) || 9;
            
            drawLattice();
        }
        
        function resetToDefaults() {
            document.getElementById('xCents').value = '3/2F';
            document.getElementById('yCents').value = '5/4F';
            updateLattice();
        }
        
        function setPreset(presetName) {
            const preset = presets[presetName];
            document.getElementById('xCents').value = preset.x;
            document.getElementById('yCents').value = preset.y;
            updateLattice();
            
            const info = document.getElementById('info');
            info.innerHTML = `Preset loaded: <strong>${preset.name}</strong>`;
            setTimeout(() => updateInfo(hoveredNode), 2000);
        }
        
        function toggleOctaveReduction() {
            isOctaveReduced = !isOctaveReduced;
            const button = document.querySelector('button[onclick="toggleOctaveReduction()"]');
            button.textContent = isOctaveReduced ? 'Unreduce from Octave' : 'Reduce to Octave';
            
            const info = document.getElementById('info');
            info.innerHTML = `<strong>${isOctaveReduced ? 'Octave reduction enabled' : 'Octave reduction disabled'}</strong> - All notes will now play ${isOctaveReduced ? 'within one octave' : 'at their full pitch'}`;
            setTimeout(() => updateInfo(hoveredNode), 2000);
        }
        
        // Keyboard controls - play notes relative to hovered position
        document.addEventListener('keydown', (e) => {
            const key = e.key.toLowerCase();
            
            // Check if this key is mapped
            if (keyMap.hasOwnProperty(key)) {
                const [offsetX, offsetY] = keyMap[key];
                
                // Calculate note position relative to hovered node (or origin if no hover)
                const baseX = hoveredNode ? hoveredNode.x : 0;
                const baseY = hoveredNode ? hoveredNode.y : 0;
                const targetX = baseX + offsetX;
                const targetY = baseY + offsetY;
                
                // Check if target is within grid
                if (targetX >= -gridSizeX && targetX <= gridSizeX && 
                    targetY >= -gridSizeY && targetY <= gridSizeY) {
                    const cents = getCentsForNode(targetX, targetY);
                    playTone(cents);
                    
                    // Show info about the played note
                    const info = document.getElementById('info');
                    const octaveReduced = ((cents % 1200) + 1200) % 1200;
                    const ratio = centsToRatio(cents);
                    info.innerHTML = `<strong>Played:</strong> (${targetX}, ${targetY}) = ${cents.toFixed(3)}¢ ` +
                        `(${octaveReduced.toFixed(3)}¢ octave-reduced) | Ratio: ${ratio.toFixed(6)}:1`;
                    setTimeout(() => updateInfo(hoveredNode), 2000);
                }
            }
        });
        
        // Initialize
        drawLattice();
    </script>
</body>
</html>
