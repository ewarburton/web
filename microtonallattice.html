<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Microtonal Lattice</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: 'Courier New', monospace;
            background: #111;
            color: #fff;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        #controls {
            background: #222;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            width: 90%;
            max-width: 800px;
        }
        
        .control-group {
            margin: 15px 0;
            display: flex;
            align-items: center;
            gap: 15px;
        }
        
        label {
            min-width: 120px;
            font-weight: bold;
        }
        
        input[type="number"],
        input[type="text"] {
            background: #333;
            border: 1px solid #555;
            color: #fff;
            padding: 8px;
            border-radius: 4px;
            width: 120px;
            font-family: 'Courier New', monospace;
        }
        
        input[type="number"]:focus,
        input[type="text"]:focus {
            outline: none;
            border-color: #0af;
        }
        
        button {
            background: #0af;
            border: none;
            color: #000;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            font-family: 'Courier New', monospace;
        }
        
        button:hover {
            background: #0cf;
        }
        
        canvas {
            border: 2px solid #333;
            background: #000;
            cursor: crosshair;
        }
        
        #info {
            margin-top: 15px;
            padding: 15px;
            background: #222;
            border-radius: 8px;
            min-height: 60px;
            width: 90%;
            max-width: 800px;
        }
        
        .preset-buttons {
            display: flex;
            gap: 10px;
            margin-top: 10px;
            flex-wrap: wrap;
        }
        
        .preset-buttons button {
            background: #555;
            font-size: 12px;
            padding: 6px 12px;
        }
        
        .preset-buttons button:hover {
            background: #777;
        }
        
        input[type="checkbox"] {
            cursor: pointer;
        }
    </style>
</head>
<body>
    <h1>Microtonal Lattice Explorer</h1>
    
    <div id="controls">
        <div class="control-group">
            <label for="xCents">X-Axis:</label>
            <input type="text" id="xCents" value="3/2F" placeholder="cents or X/YF">
            <span class="note-name">Perfect Fifth</span>
        </div>
        
        <div class="control-group">
            <label for="yCents">Y-Axis:</label>
            <input type="text" id="yCents" value="5/4F" placeholder="cents or X/YF">
            <span class="note-name">Major Third</span>
        </div>
        
        <div class="control-group">
            <label for="gridSize">Grid Size:</label>
            <input type="number" id="gridX" value="9" min="1" max="20" style="width: 60px;"> x
            <input type="number" id="gridY" value="9" min="1" max="20" style="width: 60px;">
            <span style="font-size: 12px;">(X by Y from center)</span>
        </div>
        
        <div class="control-group">
            <label for="showDivisions">Show Divisions:</label>
            <input type="checkbox" id="showDivisions" checked style="width: auto;">
        </div>
        
        <div class="control-group" id="divisionTypeControl">
            <label for="divisionType">Division Type:</label>
            <input type="range" id="divisionType" min="0" max="2" value="0" step="1" style="width: 150px;">
            <span id="divisionLabel" style="min-width: 180px; font-weight: bold;">For Divisions of the Octave</span>
        </div>
        
        <div class="control-group" id="edoControl">
            <label for="edoSlider">EDO Tuning:</label>
            <input type="range" id="edoSlider" min="5" max="53" value="12" style="width: 200px;">
            <span id="edoValue" style="min-width: 60px; font-weight: bold;">12-EDO</span>
            <button onclick="applyEDO()" style="padding: 6px 12px;">Apply</button>
        </div>
        
        <div class="control-group">
            <button onclick="updateLattice()">Update Lattice</button>
            <button onclick="toggleOctaveReduction()">Reduce to Octave</button>
            <button onclick="toggleOctaveReductionSeparate()" id="octaveReductionBtn" style="display: none;">Reduce to Octave</button>
            <button onclick="toggleWaveformMode()">Mode: Sine Finite</button>
        </div>
        
        <div class="preset-buttons">
            <button onclick="setPreset('5limit')">5-limit JI</button>
            <button onclick="setPreset('pythagorean')">Pythagorean</button>
            <button onclick="setPreset('7limit')">7-limit JI</button>
        </div>
    </div>
    
    <canvas id="lattice" width="900" height="900"></canvas>
    
    <div id="info">
        Hover over nodes to see pitch information. Click to hear the tone.
    </div>

    <script>
        const canvas = document.getElementById('lattice');
        const ctx = canvas.getContext('2d');
        let gridSizeX = 9; // X units from center
        let gridSizeY = 9; // Y units from center
        const nodeRadius = 8;
        const spacing = 45;
        
        let xCents = 701.955; // Perfect fifth (3/2)
        let yCents = 386.314; // Major third (5/4)
        let xRatio = 3/2; // Store exact ratio
        let yRatio = 5/4; // Store exact ratio
        let hoveredNode = null;
        let audioContext = null;
        let isOctaveReduced = false; // Track if we're in octave-reduced mode
        let isOctaveReducedSeparate = false; // Track octave reduction when using EDT/EDP
        let waveformMode = 'sine-finite'; // 'sine-finite' or 'sawtooth-infinite'
        let activeOscillators = new Map(); // Track active infinite oscillators by key
        let activeNodeOscillators = new Map(); // Track oscillators by node position (for canvas clicks)
        
        // Keyboard to lattice offset mapping
        const keyMap = {
            'd': [0, 0],   // touching
            'e': [0, 1],   // y up
            'c': [0, -1],  // y down
            'f': [1, 0],   // x up
            's': [-1, 0],  // x down
            'r': [1, 1],   // x+y
            'z': [-2, -1], // -2x-y
            '7': [4, 2],   // 4x+2y
            
            // Grid mapping (keyboard layout as lattice)
            '1': [-2, 2], '2': [-1, 2], '3': [0, 2], '4': [1, 2], '5': [2, 2], '6': [3, 2],
            'q': [-2, 1], 'w': [-1, 1], 't': [2, 1], 'y': [3, 1], 'u': [4, 1],
            'a': [-2, 0], 'g': [2, 0], 'h': [3, 0], 'j': [4, 0],
            'x': [-1, -1], 'v': [1, -1], 'b': [2, -1], 'n': [3, -1], 'm': [4, -1]
        };
        
        // Presets
        const presets = {
            '5limit': { x: '3/2F', y: '5/4F', name: '5-limit JI (3/2, 5/4)' },
            'pythagorean': { x: '3/2F', y: '3/2F', name: 'Pythagorean (3/2, 3/2)' },
            '7limit': { x: '3/2F', y: '7/4F', name: '7-limit JI (3/2, 7/4)' }
        };
        
        function initAudioContext() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
        }
        
        function centsToRatio(cents) {
            return Math.pow(2, cents / 1200);
        }
        
        function getPrimeFactors(n) {
            const factors = [];
            let num = n;
            for (let i = 2; i <= num; i++) {
                while (num % i === 0) {
                    factors.push(i);
                    num /= i;
                }
            }
            return factors;
        }
        
        function getUsedPrimes() {
            // Get prime factors from the current axis ratios
            const primes = new Set([2]); // Always include 2 for octaves
            
            // Add primes from xRatio
            const xFrac = ratioToSimpleFraction(xRatio);
            if (xFrac) {
                getPrimeFactors(xFrac.numer).forEach(p => primes.add(p));
                getPrimeFactors(xFrac.denom).forEach(p => primes.add(p));
            }
            
            // Add primes from yRatio
            const yFrac = ratioToSimpleFraction(yRatio);
            if (yFrac) {
                getPrimeFactors(yFrac.numer).forEach(p => primes.add(p));
                getPrimeFactors(yFrac.denom).forEach(p => primes.add(p));
            }
            
            return primes;
        }
        
        function ratioToSimpleFraction(ratio, maxDenom = 1000) {
            // Find simple fraction for a ratio
            for (let denom = 1; denom <= maxDenom; denom++) {
                const numer = Math.round(ratio * denom);
                if (Math.abs(numer / denom - ratio) < 1e-10) {
                    return { numer, denom };
                }
            }
            return null;
        }
        
        function onlyUsesAllowedPrimes(numer, denom, allowedPrimes) {
            const numerPrimes = getPrimeFactors(numer);
            const denomPrimes = getPrimeFactors(denom);
            const allPrimes = [...numerPrimes, ...denomPrimes];
            
            return allPrimes.every(p => allowedPrimes.has(p));
        }
        
        function gcd(a, b) {
            return b === 0 ? a : gcd(b, a % b);
        }
        
        function findApproxFraction(ratio, maxDenom = 1000) {
            // Find best fraction approximation without prime restrictions
            for (let denom = 1; denom <= maxDenom; denom++) {
                const numer = Math.round(ratio * denom);
                if (Math.abs(numer / denom - ratio) < 1e-9) {
                    const g = gcd(numer, denom);
                    return { numer: numer / g, denom: denom / g };
                }
            }
            return null;
        }
        
        function getFractionForNode(x, y, distance) {
            // Get base fractions for x and y axes
            const xFrac = ratioToSimpleFraction(xRatio);
            const yFrac = ratioToSimpleFraction(yRatio);
            
            if (!xFrac || !yFrac) return null;
            
            // Calculate numerator and denominator separately
            // ratio = (xNumer/xDenom)^x * (yNumer/yDenom)^y
            // Start with 1/1
            let numer = 1;
            let denom = 1;
            
            // Handle x exponent
            if (x > 0) {
                numer *= Math.pow(xFrac.numer, x);
                denom *= Math.pow(xFrac.denom, x);
            } else if (x < 0) {
                numer *= Math.pow(xFrac.denom, -x);
                denom *= Math.pow(xFrac.numer, -x);
            }
            
            // Handle y exponent
            if (y > 0) {
                numer *= Math.pow(yFrac.numer, y);
                denom *= Math.pow(yFrac.denom, y);
            } else if (y < 0) {
                numer *= Math.pow(yFrac.denom, -y);
                denom *= Math.pow(yFrac.numer, -y);
            }
            
            // Round to handle floating point errors
            numer = Math.round(numer);
            denom = Math.round(denom);
            
            // Only reduce with GCD if distance < 5
            if (distance < 5) {
                const g = gcd(numer, denom);
                numer /= g;
                denom /= g;
            }
            
            return { numer, denom };
        }
        
        function parseInput(input) {
            // Check if input is in X/YF format
            const ratioMatch = input.trim().match(/^(\d+)\/(\d+)F$/i);
            if (ratioMatch) {
                const ratio = parseInt(ratioMatch[1]) / parseInt(ratioMatch[2]);
                const cents = 1200 * Math.log2(ratio);
                return { ratio, cents };
            }
            
            // Check if input is in XF format (whole number ratio)
            const wholeMatch = input.trim().match(/^(\d+\.?\d*)F$/i);
            if (wholeMatch) {
                const ratio = parseFloat(wholeMatch[1]);
                const cents = 1200 * Math.log2(ratio);
                return { ratio, cents };
            }
            
            // Otherwise treat as cents
            const cents = parseFloat(input);
            const ratio = centsToRatio(cents);
            return { ratio, cents };
        }
        
        function getNodeId(x, y) {
            return `${x},${y}`;
        }
        
        function playTone(cents, duration = 0.5, keyId = null, nodePos = null) {
            initAudioContext();
            
            // Apply equivalence interval reduction if enabled
            let playbackCents = cents;
            if (isOctaveReduced) {
                const divisionTypeIndex = parseInt(document.getElementById('divisionType').value);
                const divisionBases = [2, 3, 5];
                const divisionBase = divisionBases[divisionTypeIndex];
                const intervalCents = 1200 * Math.log2(divisionBase);
                playbackCents = ((cents % intervalCents) + intervalCents) % intervalCents;
            }
            
            // Apply octave reduction if separate octave reduction is enabled (for EDT/EDP)
            if (isOctaveReducedSeparate) {
                playbackCents = ((playbackCents % 1200) + 1200) % 1200;
            }
            
            const baseFreq = 261.63; // Middle C
            const frequency = baseFreq * centsToRatio(playbackCents);
            
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.frequency.value = frequency;
            
            if (waveformMode === 'sawtooth-infinite') {
                oscillator.type = 'sawtooth';
                gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
                
                oscillator.start(audioContext.currentTime);
                
                // Store oscillator for later stopping
                if (keyId) {
                    // Stop any existing oscillator for this key
                    if (activeOscillators.has(keyId)) {
                        stopOscillator(keyId);
                    }
                    activeOscillators.set(keyId, { oscillator, gainNode });
                } else if (nodePos) {
                    const nodeId = getNodeId(nodePos.x, nodePos.y);
                    activeNodeOscillators.set(nodeId, { oscillator, gainNode });
                }
            } else {
                // Sine finite mode (original behavior)
                oscillator.type = 'sine';
                gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);
                
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + duration);
            }
        }
        
        function stopOscillator(keyId) {
            if (activeOscillators.has(keyId)) {
                const { oscillator, gainNode } = activeOscillators.get(keyId);
                
                // Fade out
                gainNode.gain.setValueAtTime(gainNode.gain.value, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.05);
                
                oscillator.stop(audioContext.currentTime + 0.05);
                activeOscillators.delete(keyId);
            }
        }
        
        function stopNodeOscillator(x, y) {
            const nodeId = getNodeId(x, y);
            if (activeNodeOscillators.has(nodeId)) {
                const { oscillator, gainNode } = activeNodeOscillators.get(nodeId);
                
                // Fade out
                gainNode.gain.setValueAtTime(gainNode.gain.value, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.05);
                
                oscillator.stop(audioContext.currentTime + 0.05);
                activeNodeOscillators.delete(nodeId);
                return true;
            }
            return false;
        }
        
        function isNodePlaying(x, y) {
            const nodeId = getNodeId(x, y);
            return activeNodeOscillators.has(nodeId);
        }
        
        function getCentsForNode(x, y) {
            // Calculate exact ratio first, then convert to cents
            const ratio = Math.pow(xRatio, x) * Math.pow(yRatio, y);
            return 1200 * Math.log2(ratio);
        }
        
        function getScreenPos(x, y) {
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            return {
                x: centerX + x * spacing,
                y: centerY - y * spacing // Invert Y for screen coordinates
            };
        }
        
        function drawLattice() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw grid lines
            ctx.strokeStyle = '#222';
            ctx.lineWidth = 1;
            
            for (let x = -gridSizeX; x <= gridSizeX; x++) {
                for (let y = -gridSizeY; y <= gridSizeY; y++) {
                    const pos = getScreenPos(x, y);
                    
                    // Draw connections
                    if (x < gridSizeX) {
                        const rightPos = getScreenPos(x + 1, y);
                        ctx.beginPath();
                        ctx.moveTo(pos.x, pos.y);
                        ctx.lineTo(rightPos.x, rightPos.y);
                        ctx.stroke();
                    }
                    
                    if (y < gridSizeY) {
                        const upPos = getScreenPos(x, y + 1);
                        ctx.beginPath();
                        ctx.moveTo(pos.x, pos.y);
                        ctx.lineTo(upPos.x, upPos.y);
                        ctx.stroke();
                    }
                }
            }
            
            // Draw nodes
            for (let x = -gridSizeX; x <= gridSizeX; x++) {
                for (let y = -gridSizeY; y <= gridSizeY; y++) {
                    const pos = getScreenPos(x, y);
                    const cents = getCentsForNode(x, y);
                    const octaveReduced = ((cents % 1200) + 1200) % 1200;
                    const ratio = centsToRatio(cents);
                    const distance = Math.sqrt(x * x + y * y);
                    
                    // Color based on position
                    let hue = octaveReduced / 1200 * 360;
                    let saturation = 70;
                    let lightness = 50;
                    
                    const squareSize = 50;
                    
                    // Highlight origin
                    if (x === 0 && y === 0) {
                        ctx.fillStyle = '#fff';
                        ctx.strokeStyle = '#0af';
                        ctx.lineWidth = 3;
                    } else if (hoveredNode && hoveredNode.x === x && hoveredNode.y === y) {
                        ctx.fillStyle = `hsl(${hue}, ${saturation}%, ${lightness + 20}%)`;
                        ctx.strokeStyle = '#fff';
                        ctx.lineWidth = 2;
                    } else {
                        ctx.fillStyle = `hsl(${hue}, ${saturation}%, ${lightness}%)`;
                        ctx.strokeStyle = `hsl(${hue}, ${saturation}%, ${lightness - 20}%)`;
                        ctx.lineWidth = 1;
                    }
                    
                    // Draw square
                    ctx.beginPath();
                    ctx.rect(pos.x - squareSize/2, pos.y - squareSize/2, squareSize, squareSize);
                    ctx.fill();
                    ctx.stroke();
                    
                    // Draw text
                    ctx.fillStyle = '#000';
                    ctx.font = 'bold 8px Courier New';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    
                    // Format ratio
                    let ratioText;
                    const frac = getFractionForNode(x, y, distance);
                    
                    if (frac && frac.denom === 1) {
                        ratioText = `${frac.numer}F`;
                    } else if (frac) {
                        ratioText = `${frac.numer}/${frac.denom}F`;
                    } else {
                        // Show decimal when no valid fraction exists
                        ratioText = `${ratio.toFixed(3)}F`;
                    }
                    
                    // Check if we need to split the fraction across lines
                    const needsMultiLine = frac && (
                        (frac.numer.toString().length >= 4) ||
                        (frac.numer.toString().length >= 3 && frac.denom.toString().length >= 3)
                    );
                    
                    if (needsMultiLine) {
                        // Draw numerator on top line
                        ctx.fillText(`${frac.numer}`, pos.x, pos.y - 8);
                        // Draw /denominator on bottom line
                        ctx.fillText(`/${frac.denom}F`, pos.x, pos.y + 2);
                    } else {
                        // Draw ratio on single top line
                        ctx.fillText(ratioText, pos.x, pos.y - 8);
                    }
                    
                    // Draw cents on bottom line
                    ctx.font = '8px Courier New';
                    ctx.fillText(`${Math.round(octaveReduced)}¢`, pos.x, pos.y + 12);
                }
            }
        }
        
        function getNodeAtPosition(mouseX, mouseY) {
            for (let x = -gridSizeX; x <= gridSizeX; x++) {
                for (let y = -gridSizeY; y <= gridSizeY; y++) {
                    const pos = getScreenPos(x, y);
                    const dx = mouseX - pos.x;
                    const dy = mouseY - pos.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance <= nodeRadius + 5) {
                        return { x, y, cents: getCentsForNode(x, y) };
                    }
                }
            }
            return null;
        }
        
        function updateInfo(node) {
            const info = document.getElementById('info');
            if (node) {
                const octaveReduced = ((node.cents % 1200) + 1200) % 1200;
                const octave = Math.floor(node.cents / 1200);
                const ratio = centsToRatio(node.cents);
                
                info.innerHTML = `
                    <strong>Position:</strong> (${node.x}, ${node.y})<br>
                    <strong>Cents:</strong> ${node.cents.toFixed(3)}¢ 
                    (${octaveReduced.toFixed(3)}¢ + ${octave} octaves)<br>
                    <strong>Ratio from C:</strong> ${ratio.toFixed(6)}:1
                `;
            } else {
                info.innerHTML = 'Hover over nodes to see pitch information. Click to hear the tone.<br>' +
                    '<strong>Keys:</strong> Press letter/number keys to play notes relative to hovered position (e.g., D=current, E=+Y, F=+X, R=+X+Y, 7=+4X+2Y)';
            }
        }
        
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
            hoveredNode = getNodeAtPosition(mouseX, mouseY);
            updateInfo(hoveredNode);
            drawLattice();
        });
        
        canvas.addEventListener('click', (e) => {
            if (hoveredNode) {
                // In infinite mode, toggle the note on/off
                if (waveformMode === 'sawtooth-infinite') {
                    if (isNodePlaying(hoveredNode.x, hoveredNode.y)) {
                        stopNodeOscillator(hoveredNode.x, hoveredNode.y);
                    } else {
                        playTone(hoveredNode.cents, 0.5, null, { x: hoveredNode.x, y: hoveredNode.y });
                    }
                } else {
                    // In finite mode, just play the note
                    playTone(hoveredNode.cents);
                }
            }
        });
        
        canvas.addEventListener('mouseleave', () => {
            hoveredNode = null;
            updateInfo(null);
            drawLattice();
        });
        
        function updateLattice() {
            const xInput = parseInput(document.getElementById('xCents').value);
            const yInput = parseInput(document.getElementById('yCents').value);
            
            xCents = xInput.cents;
            yCents = yInput.cents;
            xRatio = xInput.ratio;
            yRatio = yInput.ratio;
            
            // Update grid size
            gridSizeX = parseInt(document.getElementById('gridX').value) || 9;
            gridSizeY = parseInt(document.getElementById('gridY').value) || 9;
            
            drawLattice();
        }
        
        function setPreset(presetName) {
            const preset = presets[presetName];
            document.getElementById('xCents').value = preset.x;
            document.getElementById('yCents').value = preset.y;
            updateLattice();
            
            const info = document.getElementById('info');
            info.innerHTML = `Preset loaded: <strong>${preset.name}</strong>`;
            setTimeout(() => updateInfo(hoveredNode), 2000);
        }
        
        function toggleOctaveReduction() {
            isOctaveReduced = !isOctaveReduced;
            updateReductionButton();
            
            const divisionTypeIndex = parseInt(document.getElementById('divisionType').value);
            const divisionBases = [2, 3, 5];
            const divisionBase = divisionBases[divisionTypeIndex];
            const fullNames = ['Octave', 'Tritave', 'Pentave'];
            const fullName = fullNames[divisionTypeIndex];
            
            const info = document.getElementById('info');
            info.innerHTML = `<strong>${isOctaveReduced ? fullName + ' reduction enabled' : fullName + ' reduction disabled'}</strong> - All notes will now play ${isOctaveReduced ? 'within one ' + fullName.toLowerCase() : 'at their full pitch'}`;
            setTimeout(() => updateInfo(hoveredNode), 2000);
        }
        
        function updateReductionButton() {
            const divisionTypeIndex = parseInt(document.getElementById('divisionType').value);
            const fullNames = ['Octave', 'Tritave', 'Pentave'];
            const fullName = fullNames[divisionTypeIndex];
            const button = document.querySelector('button[onclick="toggleOctaveReduction()"]');
            button.textContent = isOctaveReduced ? `Unreduce from ${fullName}` : `Reduce to ${fullName}`;
        }
        
        function toggleOctaveReductionSeparate() {
            isOctaveReducedSeparate = !isOctaveReducedSeparate;
            const button = document.getElementById('octaveReductionBtn');
            button.textContent = isOctaveReducedSeparate ? 'Unreduce from Octave' : 'Reduce to Octave';
            
            const info = document.getElementById('info');
            info.innerHTML = `<strong>Octave reduction ${isOctaveReducedSeparate ? 'enabled' : 'disabled'}</strong> - All notes will now ${isOctaveReducedSeparate ? 'also be reduced to within one octave' : 'not have additional octave reduction'}`;
            setTimeout(() => updateInfo(hoveredNode), 2000);
        }
        
        function toggleWaveformMode() {
            // Stop all active oscillators when switching modes
            activeOscillators.forEach((_, key) => stopOscillator(key));
            activeNodeOscillators.forEach((_, nodeId) => {
                const [x, y] = nodeId.split(',').map(Number);
                stopNodeOscillator(x, y);
            });
            
            waveformMode = waveformMode === 'sine-finite' ? 'sawtooth-infinite' : 'sine-finite';
            const button = document.querySelector('button[onclick="toggleWaveformMode()"]');
            button.textContent = waveformMode === 'sine-finite' ? 'Mode: Sine Finite' : 'Mode: Sawtooth Infinite';
            
            const info = document.getElementById('info');
            if (waveformMode === 'sawtooth-infinite') {
                info.innerHTML = `<strong>Sawtooth Infinite mode</strong> - Notes play continuously until key is released or clicked again`;
            } else {
                info.innerHTML = `<strong>Sine Finite mode</strong> - Notes play for a fixed duration`;
            }
            setTimeout(() => updateInfo(hoveredNode), 2000);
        }
        
        function applyEDO() {
            const edo = parseInt(document.getElementById('edoSlider').value);
            const divisionTypeIndex = parseInt(document.getElementById('divisionType').value);
            
            // Map slider position to division base: 0->2 (octave), 1->3 (tritave), 2->5 (pentave)
            const divisionBases = [2, 3, 5];
            const divisionBase = divisionBases[divisionTypeIndex];
            const divisionNames = ['EDO', 'EDT', 'EDP'];
            const divisionName = divisionNames[divisionTypeIndex];
            const fullNames = ['Octave', 'Tritave', 'Pentave'];
            const fullName = fullNames[divisionTypeIndex];
            
            const stepSize = 1200 * Math.log2(divisionBase) / edo;
            
            // Calculate best approximations for perfect fifth (3/2) and major third (5/4)
            const fifthSteps = Math.round(edo * Math.log(3/2) / Math.log(divisionBase));
            const thirdSteps = Math.round(edo * Math.log(5/4) / Math.log(divisionBase));
            
            const fifthCents = fifthSteps * stepSize;
            const thirdCents = thirdSteps * stepSize;
            
            document.getElementById('xCents').value = fifthCents.toFixed(3);
            document.getElementById('yCents').value = thirdCents.toFixed(3);
            
            updateLattice();
            
            const info = document.getElementById('info');
            info.innerHTML = `<strong>${edo}-${divisionName} applied</strong> (${fullName}) - Fifth: ${fifthSteps} steps (${fifthCents.toFixed(3)}¢), Third: ${thirdSteps} steps (${thirdCents.toFixed(3)}¢)`;
            setTimeout(() => updateInfo(hoveredNode), 2000);
        }
        
        // Update division label when slider moves
        document.getElementById('divisionType').addEventListener('input', (e) => {
            const divisionNames = ['For Divisions of the Octave', 'For Divisions of the Tritave', 'For Divisions of the Pentave'];
            const typeNames = ['EDO', 'EDT', 'EDP'];
            const index = parseInt(e.target.value);
            
            document.getElementById('divisionLabel').textContent = divisionNames[index];
            
            // Update EDO value display with correct suffix
            const edo = document.getElementById('edoSlider').value;
            document.getElementById('edoValue').textContent = `${edo}-${typeNames[index]}`;
            
            // Update reduction button text
            updateReductionButton();
            
            // Show/hide separate octave reduction button (only for EDT/EDP)
            const octaveBtn = document.getElementById('octaveReductionBtn');
            octaveBtn.style.display = index > 0 ? 'inline-block' : 'none';
        });
        
        // Update EDO display when slider moves
        document.getElementById('edoSlider').addEventListener('input', (e) => {
            const edo = e.target.value;
            const divisionTypeIndex = parseInt(document.getElementById('divisionType').value);
            const typeNames = ['EDO', 'EDT', 'EDP'];
            document.getElementById('edoValue').textContent = `${edo}-${typeNames[divisionTypeIndex]}`;
        });
        
        // Toggle EDO control visibility
        document.getElementById('showDivisions').addEventListener('change', (e) => {
            const divisionTypeControl = document.getElementById('divisionTypeControl');
            const edoControl = document.getElementById('edoControl');
            const isChecked = e.target.checked;
            divisionTypeControl.style.display = isChecked ? 'flex' : 'none';
            edoControl.style.display = isChecked ? 'flex' : 'none';
        });
        
        // Keyboard controls - play notes relative to hovered position
        document.addEventListener('keydown', (e) => {
            const key = e.key.toLowerCase();
            
            // Prevent repeat events in infinite mode
            if (e.repeat && waveformMode === 'sawtooth-infinite') {
                return;
            }
            
            // Check if this key is mapped
            if (keyMap.hasOwnProperty(key)) {
                const [offsetX, offsetY] = keyMap[key];
                
                // Calculate note position relative to hovered node (or origin if no hover)
                const baseX = hoveredNode ? hoveredNode.x : 0;
                const baseY = hoveredNode ? hoveredNode.y : 0;
                const targetX = baseX + offsetX;
                const targetY = baseY + offsetY;
                
                // Check if target is within grid
                if (targetX >= -gridSizeX && targetX <= gridSizeX && 
                    targetY >= -gridSizeY && targetY <= gridSizeY) {
                    const cents = getCentsForNode(targetX, targetY);
                    playTone(cents, 0.5, key);
                    
                    // Show info about the played note
                    const info = document.getElementById('info');
                    const octaveReduced = ((cents % 1200) + 1200) % 1200;
                    const ratio = centsToRatio(cents);
                    info.innerHTML = `<strong>Played:</strong> (${targetX}, ${targetY}) = ${cents.toFixed(3)}¢ ` +
                        `(${octaveReduced.toFixed(3)}¢ octave-reduced) | Ratio: ${ratio.toFixed(6)}:1`;
                    setTimeout(() => updateInfo(hoveredNode), 2000);
                }
            }
        });
        
        // Keyboard keyup - stop infinite notes
        document.addEventListener('keyup', (e) => {
            const key = e.key.toLowerCase();
            if (waveformMode === 'sawtooth-infinite' && keyMap.hasOwnProperty(key)) {
                stopOscillator(key);
            }
        });
        
        // Initialize
        drawLattice();
    </script>
</body>
</html>
